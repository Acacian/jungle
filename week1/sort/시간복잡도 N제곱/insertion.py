def insertion_sort(arr):
    for end in range(1, len(arr)):
        i = end
        while i > 0 and arr[i - 1] > arr[i]:
            arr[i - 1], arr[i] = arr[i], arr[i - 1]
            i -= 1
# 삽입정렬은 선택정렬과 비슷한데, 선택정렬은 최소값을 찾아서 맨 앞으로 보내는 것이고
# 삽입정렬은 이미 정렬된 부분에 새로운 값을 삽입하는 것이다.
# 예를 들어 1,5,4,3,2가 있다면 앞에 1,5를 우선 비교한다.
# 1,5는 이미 정렬된 상태이기 때문에 5,4를 비교한다.
# 이후 1부터 비교하는 게 아니라 5부터 다시 왼쪽으로 비교한다. 이후 5,4를 바꿈.
# 그럼 이제 1,4,5가 되고 1,4는 이미 정렬된 상태이기 때문에 5,3을 비교한다.
# 이후 1,4,5,3이 되고 1,4,5는 이미 정렬된 상태이기 때문에 5,2를 비교한다. 이거 무한반복

def insertion_sort(arr):
    for end in range(1, len(arr)):
        to_insert = arr[end]
        # 바로 다음 것과 비교한다.
        i = end
        # 뒤에서 비교하면서 i를 줄였기 때문에 i를 다시 초기화한다.
        while i > 0 and arr[i - 1] > to_insert:
            arr[i] = arr[i - 1]
            i -= 1
            # 계속 왼쪽으로 비교하면서 삽입할 위치를 찾는다.
        arr[i] = to_insert
        # 삽입할 위치를 찾으면 그 위치에 값을 넣는다.

# 위는 swap 대신 값들을 swift해서 한번 더 최적화시킨 방법.
# 얘도 n2이긴 하지만, 최선의 경우에는 n이다.(이미 정렬이 다 된 경우)
# 버블, 선택은 최선의 경우에도 n2이다. 대신 공간복잡도는 O(1)이다.(삽입은 n)
# 그리고 swap을 하게 되면 버블, 선택은 정렬이 되어있는 경우에도 swap을 하게 된다.